<link rel="import" href="../polymerImport.html">

<dom-module id="wxr-hand-leapmotion">
	<template>
		<style>
			wxr-hand-leapmotion {
				--wxr-transform: var(--wxr-transform);
			}
		</style>
	</template>

	<script>
		'use strict';

		class WXRHandLeapmotion extends WXRPeriphaeralHand {
			constructor() {
				super();
				this.hands = [];
				this.deltaRightThumbVector = new THREE.Vector3();
			}

			static get is() {
				return "wxr-hand-leapmotion";
			}

			static get properties() {
				return {

				};
			}

			connectedCallback() {
				super.connectedCallback();

				if(this.parentElement.tagName.startsWith(WXR.PREFIX_WXR)) {
					this.addEventListener(WXREvent.TARGET_ABAILABLE, this.onTargetAvailable);
					this.addEventListener(WXREventDevice.HANDGESTURE_DETECTED, this.onLeapDetected);
					this.addEventListener(WXREventDevice.HANDGESTURE_MOVED, this.onLeapMoved);
					this.addEventListener(WXREventDevice.HANDGESTURE_MISSED, this.onLeapMissed);
				}
			}
			onTargetAvailable(e) {
				// console.log('leap: onTargetAvailable', e);
				// this.createHand();
				// if ((typeof(WebSocket) == 'undefined') &&
				// 	(typeof(MozWebSocket) != 'undefined')) {
				// 	WebSocket = MozWebSocket;
				// }
			}

			onLeapDetected(e) {
				// console.log('leap: onLeapDetected', e);
				this.createHand();
				/*
				* leapMotion Detected
				*
				* hand model visible
				* */
			}

			onLeapMoved(e) {
				// console.log('leap: onLeapMoved', e);
				this.updateHandPosition(e.detail.frame);
				this.collisionDetect();

				/*
				* leapMotion Moved
				*
				* hand position update
				* */
			}

			onLeapMissed(e) {
				// console.log('leap: onLeapMissed', e);
				this.removeHand();
				/*
				* leapMotion Missed
				*
				* hand model invisible
				* */
			}

			createHand() {
				this.hands=[];
				let group = new THREE.Group();

				let jointGeometry = new THREE.SphereGeometry(0.015, 32, 32);
				// let jointMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});

				// bone order: R, B, Y, A, G
				let btip = new THREE.MeshBasicMaterial({color: 0xff0000});
				let carp = new THREE.MeshBasicMaterial({color: 0x00ff00});
				let dip = new THREE.MeshBasicMaterial({color: 0x0000ff});
				let mcp = new THREE.MeshBasicMaterial({color: 0xffff00});
				let pip = new THREE.MeshBasicMaterial({color: 0x00ffff});

				for(let i=0; i<2; i++) {
					let fingers = [];

					for(let j=0; j<5; j++) {
						let finger = {
							handType: (i===0)?"left":"right",
							fingerType: j,
							btipPosition: new THREE.Mesh(jointGeometry, btip),
							carpPosition: new THREE.Mesh(jointGeometry, carp),
							dipPosition: new THREE.Mesh(jointGeometry, dip),
							mcpPosition: new THREE.Mesh(jointGeometry, mcp),
							pipPosition: new THREE.Mesh(jointGeometry, pip)
						};

						group.add(finger.btipPosition);
						group.add(finger.carpPosition);
						group.add(finger.dipPosition);
						group.add(finger.mcpPosition);
						group.add(finger.pipPosition);

						fingers[j] = finger;
					}
					this.hands[(i===0)?"left":"right"] = fingers;
				}

				this.addWebGLObject3D(group);

				this.webGLObject3D.rotation.set(-1.57, 0, 0);
			}

			updateHandPosition(leap) {
				let leftHandId, rightHandId;

				for(let hand of leap.hands) {
					if(hand.type === "left") {
						leftHandId = hand.id
					} else if(hand.type === "right") {
						rightHandId = hand.id;
					}
				}

				if(leap.pointables.length > 0 && this.hands.left || this.hands.right) {
					for(let finger of leap.pointables) {
						let handType = (finger.handId === leftHandId)?"left":"right";

						let fingerModel = this.hands[handType][finger.type];

						if (handType === 'right') this.deltaRightThumbVector.fromArray(finger.btipPosition.map( e => e/1000 )).sub(fingerModel.btipPosition.position);

						fingerModel.btipPosition.position.fromArray(finger.btipPosition.map( e => e/1000 ));
						fingerModel.carpPosition.position.fromArray(finger.carpPosition.map( e => e/1000 ));
						fingerModel.dipPosition.position.fromArray(finger.dipPosition.map( e => e/1000 ));
						fingerModel.mcpPosition.position.fromArray(finger.mcpPosition.map( e => e/1000 ));
						fingerModel.pipPosition.position.fromArray(finger.pipPosition.map( e => e/1000 ));
						// fingerModel.tipPosition.position.fromArray(finger.tipPosition);
					}
				}
			}

			removeHand() {
				this.hands=[];
				this.removeWebGLObject3D();
			}

			collisionDetect() {

				const leftCollided = [];
				const rightThunbCollided = [];
				const rightIndexCollided = [];
				const meshes = $(WXRWorld.is)[0].renderer.getTargetWebGLObjects();

				// finger.type: 0 -> thumb, 1 -> index, ...
				const leftThumbFinger = this.hands['left'][0]['btipPosition'];
				const rightThumbFinger = this.hands['right'][0]['btipPosition'];
				const rightIndexFinger = this.hands['right'][1]['btipPosition'];

				// const targets = $(WXRWorld.is)[0].renderer.getWebGLScene().children;
				const targets = Array.from($(WXRBox.is)).map( e => e.webGLObject3D);

				var raycaster = new THREE.Raycaster(rightThumbFinger.position.clone(), targets[0].position.clone().sub(rightThumbFinger.position.clone()), 0, rightThumbFinger.geometry.boundingSphere.radius );
				var intersects = raycaster.intersectObject( targets[0] );
				intersects.forEach( target => {
					if (target.distance < rightThumbFinger.geometry.boundingSphere.radius) {
						rightThunbCollided.push(target);
					}
				});

				var raycaster = new THREE.Raycaster(rightIndexFinger.position.clone(), targets[0].position.clone().sub(rightIndexFinger.position.clone()), 0, rightIndexFinger.geometry.boundingSphere.radius );
				var intersects = raycaster.intersectObject( targets[0] );
				intersects.forEach( target => {
					if (target.distance < rightIndexFinger.geometry.boundingSphere.radius) {
						rightIndexCollided.push(target);
					}
				});

				if (rightThunbCollided[0] && rightIndexCollided[0] && rightThunbCollided[0].object.uuid === rightIndexCollided[0].object.uuid) {
					rightThunbCollided[0].object.position.multiplyScalar(1).add(this.deltaRightThumbVector);
				}

				// var raycaster = new THREE.Raycaster(rightThumbFinger.position.clone());
				// var intersects = raycaster.intersectObjects( targets, true );
				// intersects.forEach( target => {
				// 	if (target.distance < rightThumbFinger.radius) {
				// 		rightCollided.push(target);
				// 	}
				// });

				// var object = leftThumbFinger;
				// var originPoint = object.position.clone();
				// meshes.forEach( target => {
				//     var directionVector = target.position.clone().sub(originPoint);
				//
				// 	var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
				// 	var collisionResults = ray.intersectObject(target);
				// 	if (collisionResults.length > 0 && collisionResults[0].distance < object.radius) {
				// 		leftCollided.push(collisionResults[0]);
				// 	}
				// });


				// var object = rightThumbFinger;
				// var originPoint = object.position.clone();
				// for (var vertexIndex = 0; vertexIndex < object.geometry.vertices.length; vertexIndex++) {
				// 	var localVertex = object.geometry.vertices[vertexIndex].clone();
				// 	var globalVertex = localVertex.applyMatrix4(object.matrix);
				// 	var directionVector = globalVertex.sub(object.position);
				//
				// 	var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
				// 	var collisionResults = ray.intersectObjects(meshes);
				// 	if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
				// 		rightCollided.push(collisionResults[0]);
				// 	}
				// }

			}

		}

		customElements.define(WXRHandLeapmotion.is, WXRHandLeapmotion);

	</script>
</dom-module>