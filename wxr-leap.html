<link rel="import" href="./polymerImport.html">

<dom-module id="wxr-box">
	<template>
		<style>
			wxr-box {
				--wxr-transform: var(--wxr-transform);
			}
		</style>
	</template>

	<script>
		'use strict';

		class WXRLeap extends WXRElement {
			constructor() {
				super();
			}

			static get is() {
				return "wxr-leap";
			}

			static get properties() {
				return {

				};
			}

			connectedCallback() {
				super.connectedCallback();

				if(this.parentElement.tagName.startsWith(WXR.PREFIX_WXR)) {
					this.addEventListener(WXREvent.TARGET_ABAILABLE, this.onTargetAvailable);
					this.addEventListener('WXRInteractionLeapDetected', this.onLeapDetected);
					this.addEventListener('WXRInteractionLeapMoved', this.onLeapMoved);
					this.addEventListener('WXRInteractionLeapMissed', this.onLeapMissed);
				}
			}
			onTargetAvailable(e) {
				if ((typeof(WebSocket) == 'undefined') &&
					(typeof(MozWebSocket) != 'undefined')) {
					WebSocket = MozWebSocket;
				}
				this.createHand();
				this.connectToWebSocket();
			}

			onLeapDetected(e) {
				/*
				* leapMotion Detected
				*
				* hand model visible
				* */
			}

			onLeapMoved(e) {
				/*
				* leapMotion Moved
				*
				* hand position update
				* */
			}

			onLeapMissed(e) {
				/*
				* leapMotion Missed
				*
				* hand model invisible
				* */
			}

			connectToWebSocket() {
				// Create and open the socket
				let ws = new WebSocket("ws://localhost:6437/v6.json");

				// On successful connection
				ws.onopen = function(event) {
					var enableMessage = JSON.stringify({enableGestures: true});
					ws.send(enableMessage); // Enable gestures
					var backgroundMessage = JSON.stringify({background: true});
					ws.send(backgroundMessage); // Get frames in background
					console.log("open");
				};

				// On message received
				ws.onmessage = function(event) {
					var obj = JSON.parse(event.data);
					var str = JSON.stringify(obj, undefined, 2);
					if(obj.id){
						this.updateHandPosition(obj);
						// console.log("Frame data for " + JSON.stringify(obj));
					} else {
						console.log("message " + event.data);
					}
				}.bind(this);

				// On socket close
				ws.onclose = function(event) {
					ws = null;
					console.log("close");
				}

				// On socket error
				ws.onerror = function(event) {
					console.log("error");
				};
			}

			createHand() {
				this.hands=[];
				let group = new THREE.Group();

				let jointGeometry = new THREE.SphereGeometry(10, 10, 10);
				// let jointMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});

				let btip = new THREE.MeshBasicMaterial({color: 0xff0000});
				let carp = new THREE.MeshBasicMaterial({color: 0x00ff00});
				let dip = new THREE.MeshBasicMaterial({color: 0x0000ff});
				let mcp = new THREE.MeshBasicMaterial({color: 0xffff00});
				let pip = new THREE.MeshBasicMaterial({color: 0x00ffff});

				for(let i=0; i<2; i++) {
					let fingers = [];

					for(let j=0; j<5; j++) {
						let finger = {
							handType: (i===0)?"left":"right",
							fingerType: j,
							btipPosition: new THREE.Mesh(jointGeometry, btip),
							carpPosition: new THREE.Mesh(jointGeometry, carp),
							dipPosition: new THREE.Mesh(jointGeometry, dip),
							mcpPosition: new THREE.Mesh(jointGeometry, mcp),
							pipPosition: new THREE.Mesh(jointGeometry, pip)
						};

						group.add(finger.btipPosition);
						group.add(finger.carpPosition);
						group.add(finger.dipPosition);
						group.add(finger.mcpPosition);
						group.add(finger.pipPosition);

						fingers[j] = finger;
					}
					this.hands[(i===0)?"left":"right"] = fingers;
				}

				this.addWebGLObject3D(group);
			}

			updateHandPosition(leap) {
				let leftHandId, rightHandId;

				for(let hand of leap.hands) {
					if(hand.type === "left") {
						leftHandId = hand.id
					} else if(hand.type === "right") {
						rightHandId = hand.id;
					}
				}

				if(leap.pointables.length > 0) {
					for(let finger of leap.pointables) {
						let handType = (finger.handId === leftHandId)?"left":"right";

						let fingerModel = this.hands[handType][finger.type];

						fingerModel.btipPosition.position.fromArray(finger.btipPosition);
						fingerModel.carpPosition.position.fromArray(finger.carpPosition);
						fingerModel.dipPosition.position.fromArray(finger.dipPosition);
						fingerModel.mcpPosition.position.fromArray(finger.mcpPosition);
						fingerModel.pipPosition.position.fromArray(finger.pipPosition);
						// fingerModel.tipPosition.position.fromArray(finger.tipPosition);
					}
				}
			}
		}

		customElements.define(WXRLeap.is, WXRLeap);

	</script>
</dom-module>