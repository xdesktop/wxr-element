<link rel="import" href="./polymerImport.html">

<dom-module id="wxr-box">
	<template>
		<style>
			wxr-box {
				--wxr-transform: var(--wxr-transform);
			}
		</style>
	</template>

	<script>
		'use strict';

		class WXRLeap extends WXRElement {
			constructor() {
				super();
				this.hands = [];
			}

			static get is() {
				return "wxr-leap";
			}

			static get properties() {
				return {

				};
			}

			connectedCallback() {
				super.connectedCallback();

				if(this.parentElement.tagName.startsWith(WXR.PREFIX_WXR)) {
					this.addEventListener(WXREvent.TARGET_ABAILABLE, this.onTargetAvailable);
					this.addEventListener(WXREventDevice.HANDGESTURE_DETECTED, this.onLeapDetected);
					this.addEventListener(WXREventDevice.HANDGESTURE_MOVED, this.onLeapMoved);
					this.addEventListener(WXREventDevice.HANDGESTURE_MISSED, this.onLeapMissed);
				}
			}
			onTargetAvailable(e) {
				console.log('leap: onTargetAvailable', e);
				this.createHand();
				// if ((typeof(WebSocket) == 'undefined') &&
				// 	(typeof(MozWebSocket) != 'undefined')) {
				// 	WebSocket = MozWebSocket;
				// }
			}

			onLeapDetected(e) {
				console.log('leap: onLeapDetected', e);
				this.createHand();
				/*
				* leapMotion Detected
				*
				* hand model visible
				* */
			}

			onLeapMoved(e) {
				console.log('leap: onLeapMoved', e);
				this.updateHandPosition(e.detail.frame);
				/*
				* leapMotion Moved
				*
				* hand position update
				* */
			}

			onLeapMissed(e) {
				console.log('leap: onLeapMissed', e);
				this.removeHand();
				/*
				* leapMotion Missed
				*
				* hand model invisible
				* */
			}

			// connectToWebSocket() {
			// 	// Create and open the socket
			// 	let ws = new WebSocket("ws://localhost:6437/v6.json");
			//
			// 	// On successful connection
			// 	ws.onopen = function(event) {
			// 		var enableMessage = JSON.stringify({enableGestures: true});
			// 		ws.send(enableMessage); // Enable gestures
			// 		var backgroundMessage = JSON.stringify({background: true});
			// 		ws.send(backgroundMessage); // Get frames in background
			// 		console.log("open");
			// 	};
			//
			// 	// On message received
			// 	ws.onmessage = function(event) {
			// 		var obj = JSON.parse(event.data);
			// 		var str = JSON.stringify(obj, undefined, 2);
			// 		if(obj.id){
			// 			this.updateHandPosition(obj);
			// 			// console.log("Frame data for " + JSON.stringify(obj));
			// 		} else {
			// 			console.log("message " + event.data);
			// 		}
			// 	}.bind(this);
			//
			// 	// On socket close
			// 	ws.onclose = function(event) {
			// 		ws = null;
			// 		console.log("close");
			// 	}
			//
			// 	// On socket error
			// 	ws.onerror = function(event) {
			// 		console.log("error");
			// 	};
			// }

			createHand() {
				this.hands=[];
				let group = new THREE.Group();

				let jointGeometry = new THREE.SphereGeometry(10, 10, 10);
				// let jointMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});

				let btip = new THREE.MeshBasicMaterial({color: 0xff0000});
				let carp = new THREE.MeshBasicMaterial({color: 0x00ff00});
				let dip = new THREE.MeshBasicMaterial({color: 0x0000ff});
				let mcp = new THREE.MeshBasicMaterial({color: 0xffff00});
				let pip = new THREE.MeshBasicMaterial({color: 0x00ffff});

				for(let i=0; i<2; i++) {
					let fingers = [];

					for(let j=0; j<5; j++) {
						let finger = {
							handType: (i===0)?"left":"right",
							fingerType: j,
							btipPosition: new THREE.Mesh(jointGeometry, btip),
							carpPosition: new THREE.Mesh(jointGeometry, carp),
							dipPosition: new THREE.Mesh(jointGeometry, dip),
							mcpPosition: new THREE.Mesh(jointGeometry, mcp),
							pipPosition: new THREE.Mesh(jointGeometry, pip)
						};

						group.add(finger.btipPosition);
						group.add(finger.carpPosition);
						group.add(finger.dipPosition);
						group.add(finger.mcpPosition);
						group.add(finger.pipPosition);

						fingers[j] = finger;
					}
					this.hands[(i===0)?"left":"right"] = fingers;
				}

				this.addWebGLObject3D(group);
			}

			updateHandPosition(leap) {
				let leftHandId, rightHandId;

				for(let hand of leap.hands) {
					if(hand.type === "left") {
						leftHandId = hand.id
					} else if(hand.type === "right") {
						rightHandId = hand.id;
					}
				}

				if(leap.pointables.length > 0 && this.hands.length > 0) {
					for(let finger of leap.pointables) {
						let handType = (finger.handId === leftHandId)?"left":"right";

						let fingerModel = this.hands[handType][finger.type];

						fingerModel.btipPosition.position.fromArray(finger.btipPosition);
						fingerModel.carpPosition.position.fromArray(finger.carpPosition);
						fingerModel.dipPosition.position.fromArray(finger.dipPosition);
						fingerModel.mcpPosition.position.fromArray(finger.mcpPosition);
						fingerModel.pipPosition.position.fromArray(finger.pipPosition);
						// fingerModel.tipPosition.position.fromArray(finger.tipPosition);
					}
				}
			}

			removeHand() {
				this.hands=[];
				this.removeWebGLObject3D();
			}
		}

		customElements.define(WXRLeap.is, WXRLeap);

	</script>
</dom-module>